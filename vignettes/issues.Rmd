---
title: Cleaning data using GBIF issues
author: Scott Chamberlain
date: "2020-11-10"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{cleaning}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



`rgbif` now has the ability to clean data retrieved from GBIF based on GBIF issues. These issues are returned in data retrieved from GBIF, e.g., through the `occ_search()` function. Inspired by `magrittr`, we've setup a workflow for cleaning data based on using the operator `%>%`. You don't have to use it, but as we show below, it can make the process quite easy.

Note that you can also query based on issues, e.g., `occ_search(taxonKey=1, issue='DEPTH_UNLIKELY')`. However, we imagine it's more likely that you want to search for occurrences based on a taxonomic name, or geographic area, not based on issues, so it makes sense to pull data down, then clean as needed using the below workflow with `occ_issues()`.

Note that `occ_issues()` only affects the data element in the gbif class that is returned from a call to `occ_search()`. Maybe in a future version we will remove the associated records from the hierarchy and media elements as they are remove from the data element.

`occ_issues()` also works with data from `occ_download()`.

## Get rgbif

Install from CRAN


```r
install.packages("rgbif")
```

Or install the development version from GitHub


```r
remotes::install_github("ropensci/rgbif")
```

Load rgbif


```r
library('rgbif')
```

## Get some data

Get taxon key for _Helianthus annuus_


```r
(key <- name_suggest(q='Helianthus annuus', rank='species')$key[1])
#> NULL
```

Then pass to `occ_search()`


```r
(res <- occ_search(taxonKey=key, limit=100))
#> Records found [1631169502] 
#> Records returned [100] 
#> No. unique hierarchies [77] 
#> No. media records [100] 
#> No. facets [0] 
#> Args [limit=100, offset=0, fields=all] 
#> # A tibble: 100 x 111
#>    key   scientificName issues datasetKey publishingOrgKey installationKey
#>    <chr> <chr>          <chr>  <chr>      <chr>            <chr>          
#>  1 1039… Psittacus eri… "osii… 854cf79e-… 2e167bb0-4441-1… 3f28c5e9-59b3-…
#>  2 1086… Asplenium rad… "gass… a51fa32f-… f6e2efc9-42a3-4… b38ff2b7-c8af-…
#>  3 1095… Eugenia pyrif… ""     3b8e9d83-… ab5c0b99-5af3-4… b38ff2b7-c8af-…
#>  4 1135… Marasmius epi… ""     0afba960-… 58520c30-bafb-1… 602f7766-f762-…
#>  5 1135… Berkleasmium … ""     0afba960-… 58520c30-bafb-1… 602f7766-f762-…
#>  6 1135… Pseudovalsa u… ""     0afba960-… 58520c30-bafb-1… 602f7766-f762-…
#>  7 1135… Hemitrichia i… ""     0afba960-… 58520c30-bafb-1… 602f7766-f762-…
#>  8 1830… Diatrypella f… ""     0afba960-… 58520c30-bafb-1… 602f7766-f762-…
#>  9 1830… Cryptocline t… ""     0afba960-… 58520c30-bafb-1… 602f7766-f762-…
#> 10 1840… Asota helicon… "osii… e0b8cb67-… 7c07cec1-2925-4… 08eefeeb-e20f-…
#> # … with 90 more rows, and 105 more variables: publishingCountry <chr>,
#> #   protocol <chr>, lastCrawled <chr>, lastParsed <chr>, crawlId <int>,
#> #   extensions <chr>, basisOfRecord <chr>, individualCount <int>,
#> #   occurrenceStatus <chr>, taxonKey <int>, kingdomKey <int>, phylumKey <int>,
#> #   classKey <int>, orderKey <int>, familyKey <int>, genusKey <int>,
#> #   speciesKey <int>, acceptedTaxonKey <int>, acceptedScientificName <chr>,
#> #   kingdom <chr>, phylum <chr>, order <chr>, family <chr>, genus <chr>,
#> #   species <chr>, genericName <chr>, specificEpithet <chr>, taxonRank <chr>,
#> #   taxonomicStatus <chr>, year <int>, month <int>, eventDate <chr>,
#> #   modified <chr>, lastInterpreted <chr>, references <chr>, license <chr>,
#> #   identifiers <chr>, facts <chr>, relations <chr>, gadm <chr>, class <chr>,
#> #   recordedByIDs <chr>, identifiedByIDs <chr>, rightsHolder <chr>,
#> #   identifier <chr>, nomenclaturalCode <chr>, gbifID <chr>,
#> #   collectionCode <chr>, language <chr>, occurrenceID <chr>, type <chr>,
#> #   taxonRemarks <chr>, preparations <chr>, disposition <chr>,
#> #   recordedBy <chr>, catalogNumber <chr>, vernacularName <chr>,
#> #   previousIdentifications <chr>, institutionCode <chr>,
#> #   ownerInstitutionCode <chr>, datasetID <chr>, occurrenceRemarks <chr>,
#> #   bibliographicCitation <chr>, accessRights <chr>,
#> #   higherClassification <chr>, name <chr>, decimalLatitude <dbl>,
#> #   decimalLongitude <dbl>, dateIdentified <chr>, elevation <dbl>,
#> #   elevationAccuracy <dbl>, stateProvince <chr>, day <int>,
#> #   gadm.level0.gid <chr>, gadm.level0.name <chr>, gadm.level1.gid <chr>,
#> #   gadm.level1.name <chr>, gadm.level2.gid <chr>, gadm.level2.name <chr>,
#> #   gadm.level3.gid <chr>, gadm.level3.name <chr>, geodeticDatum <chr>,
#> #   countryCode <chr>, country <chr>, recordNumber <chr>, municipality <chr>,
#> #   locality <chr>, datasetName <chr>, identifiedBy <chr>, continent <chr>,
#> #   typifiedName <chr>, lifeStage <chr>, infraspecificEpithet <chr>,
#> #   county <chr>, associatedReferences <chr>, verbatimElevation <chr>,
#> #   higherGeography <chr>, institutionID <chr>, island <chr>,
#> #   islandGroup <chr>, …
```

## Examine issues

The dataset `gbifissues` can be retrieved using the function `gbif_issues()`. The dataset's first column `code` is a code that is used by default in the results from `occ_search()`, while the second column `issue` is the full issue name given by GBIF. The third column is a full description of the issue.


```r
head(gbif_issues())
#>    code                              issue
#> 1   bri            BASIS_OF_RECORD_INVALID
#> 2   ccm         CONTINENT_COUNTRY_MISMATCH
#> 3   cdc CONTINENT_DERIVED_FROM_COORDINATES
#> 4 conti                  CONTINENT_INVALID
#> 5  cdiv                 COORDINATE_INVALID
#> 6 cdout            COORDINATE_OUT_OF_RANGE
#>                                                                                                    description
#> 1 The given basis of record is impossible to interpret or seriously different from the recommended vocabulary.
#> 2                                                       The interpreted continent and country do not match up.
#> 3                  The interpreted continent is based on the coordinates, not the verbatim string information.
#> 4                                                                      Uninterpretable continent values found.
#> 5                                      Coordinate value given in some form but GBIF is unable to interpret it.
#> 6                                        Coordinate has invalid lat/lon values out of their decimal max range.
#>         type
#> 1 occurrence
#> 2 occurrence
#> 3 occurrence
#> 4 occurrence
#> 5 occurrence
#> 6 occurrence
```

You can query to get certain issues


```r
gbif_issues()[ gbif_issues()$code %in% c('cdround','cudc','gass84','txmathi'), ]
#>       code                            issue
#> 10 cdround               COORDINATE_ROUNDED
#> 12    cudc COUNTRY_DERIVED_FROM_COORDINATES
#> 23  gass84     GEODETIC_DATUM_ASSUMED_WGS84
#> 39 txmathi           TAXON_MATCH_HIGHERRANK
#>                                                                                                                                 description
#> 10                                                                                  Original coordinate modified by rounding to 5 decimals.
#> 12                                                The interpreted country is based on the coordinates, not the verbatim string information.
#> 23 Indicating that the interpreted coordinates assume they are based on WGS84 datum as the datum was either not indicated or interpretable.
#> 39                                        Matching to the taxonomic backbone can only be done on a higher rank and not the scientific name.
#>          type
#> 10 occurrence
#> 12 occurrence
#> 23 occurrence
#> 39 occurrence
```

The code `cdround` represents the GBIF issue `COORDINATE_ROUNDED`, which means that

> Original coordinate modified by rounding to 5 decimals.

The content for this information comes from https://gbif.github.io/gbif-api/apidocs/org/gbif/api/vocabulary/OccurrenceIssue.html

## Parse data based on issues

Now that we know a bit about GBIF issues, you can parse your data based on issues. Using the data generated above, and using the function `%>%` imported from `magrittr`, we can get only data with the issue `gass84`, or `GEODETIC_DATUM_ASSUMED_WGS84` (Note how the records returned goes down to 98 instead of the initial 100).


```r
res %>%
  occ_issues(gass84)
#> Records found [1631169502] 
#> Records returned [84] 
#> No. unique hierarchies [77] 
#> No. media records [100] 
#> No. facets [0] 
#> Args [limit=100, offset=0, fields=all] 
#> # A tibble: 84 x 111
#>    key   scientificName issues datasetKey publishingOrgKey installationKey
#>    <chr> <chr>          <chr>  <chr>      <chr>            <chr>          
#>  1 1086… Asplenium rad… gass84 a51fa32f-… f6e2efc9-42a3-4… b38ff2b7-c8af-…
#>  2 1880… Limnonectes w… gass84 dce00a1f-… b554c320-0560-1… c7b49e46-602a-…
#>  3 1880… Limnonectes w… gass84 dce00a1f-… b554c320-0560-1… c7b49e46-602a-…
#>  4 1880… Limnonectes w… gass84 dce00a1f-… b554c320-0560-1… c7b49e46-602a-…
#>  5 1897… Polystichum w… cdrou… 83ae84cf-… 32e82a64-c9b4-4… 58f76e14-f21d-…
#>  6 1897… Epacris pauci… cdrou… 83ae84cf-… 32e82a64-c9b4-4… 58f76e14-f21d-…
#>  7 1897… Metrosideros … cdrou… 83ae84cf-… 32e82a64-c9b4-4… 58f76e14-f21d-…
#>  8 1897… Potentilla an… cdrou… 83ae84cf-… 32e82a64-c9b4-4… 58f76e14-f21d-…
#>  9 1897… Ranunculus ni… cdrou… 83ae84cf-… 32e82a64-c9b4-4… 58f76e14-f21d-…
#> 10 1897… Blechnum memb… cdrou… 83ae84cf-… 32e82a64-c9b4-4… 58f76e14-f21d-…
#> # … with 74 more rows, and 105 more variables: publishingCountry <chr>,
#> #   protocol <chr>, lastCrawled <chr>, lastParsed <chr>, crawlId <int>,
#> #   extensions <chr>, basisOfRecord <chr>, individualCount <int>,
#> #   occurrenceStatus <chr>, taxonKey <int>, kingdomKey <int>, phylumKey <int>,
#> #   classKey <int>, orderKey <int>, familyKey <int>, genusKey <int>,
#> #   speciesKey <int>, acceptedTaxonKey <int>, acceptedScientificName <chr>,
#> #   kingdom <chr>, phylum <chr>, order <chr>, family <chr>, genus <chr>,
#> #   species <chr>, genericName <chr>, specificEpithet <chr>, taxonRank <chr>,
#> #   taxonomicStatus <chr>, year <int>, month <int>, eventDate <chr>,
#> #   modified <chr>, lastInterpreted <chr>, references <chr>, license <chr>,
#> #   identifiers <chr>, facts <chr>, relations <chr>, gadm <chr>, class <chr>,
#> #   recordedByIDs <chr>, identifiedByIDs <chr>, rightsHolder <chr>,
#> #   identifier <chr>, nomenclaturalCode <chr>, gbifID <chr>,
#> #   collectionCode <chr>, language <chr>, occurrenceID <chr>, type <chr>,
#> #   taxonRemarks <chr>, preparations <chr>, disposition <chr>,
#> #   recordedBy <chr>, catalogNumber <chr>, vernacularName <chr>,
#> #   previousIdentifications <chr>, institutionCode <chr>,
#> #   ownerInstitutionCode <chr>, datasetID <chr>, occurrenceRemarks <chr>,
#> #   bibliographicCitation <chr>, accessRights <chr>,
#> #   higherClassification <chr>, name <chr>, decimalLatitude <dbl>,
#> #   decimalLongitude <dbl>, dateIdentified <chr>, elevation <dbl>,
#> #   elevationAccuracy <dbl>, stateProvince <chr>, day <int>,
#> #   gadm.level0.gid <chr>, gadm.level0.name <chr>, gadm.level1.gid <chr>,
#> #   gadm.level1.name <chr>, gadm.level2.gid <chr>, gadm.level2.name <chr>,
#> #   gadm.level3.gid <chr>, gadm.level3.name <chr>, geodeticDatum <chr>,
#> #   countryCode <chr>, country <chr>, recordNumber <chr>, municipality <chr>,
#> #   locality <chr>, datasetName <chr>, identifiedBy <chr>, continent <chr>,
#> #   typifiedName <chr>, lifeStage <chr>, infraspecificEpithet <chr>,
#> #   county <chr>, associatedReferences <chr>, verbatimElevation <chr>,
#> #   higherGeography <chr>, institutionID <chr>, island <chr>,
#> #   islandGroup <chr>, …
```

Note also that we've set up `occ_issues()` so that you can pass in issue names without having to quote them, thereby speeding up data cleaning.

Next, we can remove data with certain issues just as easily by using a `-` sign in front of the variable, like this, removing data with issues `depunl` and `mdatunl`.


```r
res %>%
  occ_issues(-depunl, -mdatunl)
#> Records found [1631169502] 
#> Records returned [100] 
#> No. unique hierarchies [77] 
#> No. media records [100] 
#> No. facets [0] 
#> Args [limit=100, offset=0, fields=all] 
#> # A tibble: 100 x 111
#>    key   scientificName issues datasetKey publishingOrgKey installationKey
#>    <chr> <chr>          <chr>  <chr>      <chr>            <chr>          
#>  1 1039… Psittacus eri… "osii… 854cf79e-… 2e167bb0-4441-1… 3f28c5e9-59b3-…
#>  2 1086… Asplenium rad… "gass… a51fa32f-… f6e2efc9-42a3-4… b38ff2b7-c8af-…
#>  3 1095… Eugenia pyrif… ""     3b8e9d83-… ab5c0b99-5af3-4… b38ff2b7-c8af-…
#>  4 1135… Marasmius epi… ""     0afba960-… 58520c30-bafb-1… 602f7766-f762-…
#>  5 1135… Berkleasmium … ""     0afba960-… 58520c30-bafb-1… 602f7766-f762-…
#>  6 1135… Pseudovalsa u… ""     0afba960-… 58520c30-bafb-1… 602f7766-f762-…
#>  7 1135… Hemitrichia i… ""     0afba960-… 58520c30-bafb-1… 602f7766-f762-…
#>  8 1830… Diatrypella f… ""     0afba960-… 58520c30-bafb-1… 602f7766-f762-…
#>  9 1830… Cryptocline t… ""     0afba960-… 58520c30-bafb-1… 602f7766-f762-…
#> 10 1840… Asota helicon… "osii… e0b8cb67-… 7c07cec1-2925-4… 08eefeeb-e20f-…
#> # … with 90 more rows, and 105 more variables: publishingCountry <chr>,
#> #   protocol <chr>, lastCrawled <chr>, lastParsed <chr>, crawlId <int>,
#> #   extensions <chr>, basisOfRecord <chr>, individualCount <int>,
#> #   occurrenceStatus <chr>, taxonKey <int>, kingdomKey <int>, phylumKey <int>,
#> #   classKey <int>, orderKey <int>, familyKey <int>, genusKey <int>,
#> #   speciesKey <int>, acceptedTaxonKey <int>, acceptedScientificName <chr>,
#> #   kingdom <chr>, phylum <chr>, order <chr>, family <chr>, genus <chr>,
#> #   species <chr>, genericName <chr>, specificEpithet <chr>, taxonRank <chr>,
#> #   taxonomicStatus <chr>, year <int>, month <int>, eventDate <chr>,
#> #   modified <chr>, lastInterpreted <chr>, references <chr>, license <chr>,
#> #   identifiers <chr>, facts <chr>, relations <chr>, gadm <chr>, class <chr>,
#> #   recordedByIDs <chr>, identifiedByIDs <chr>, rightsHolder <chr>,
#> #   identifier <chr>, nomenclaturalCode <chr>, gbifID <chr>,
#> #   collectionCode <chr>, language <chr>, occurrenceID <chr>, type <chr>,
#> #   taxonRemarks <chr>, preparations <chr>, disposition <chr>,
#> #   recordedBy <chr>, catalogNumber <chr>, vernacularName <chr>,
#> #   previousIdentifications <chr>, institutionCode <chr>,
#> #   ownerInstitutionCode <chr>, datasetID <chr>, occurrenceRemarks <chr>,
#> #   bibliographicCitation <chr>, accessRights <chr>,
#> #   higherClassification <chr>, name <chr>, decimalLatitude <dbl>,
#> #   decimalLongitude <dbl>, dateIdentified <chr>, elevation <dbl>,
#> #   elevationAccuracy <dbl>, stateProvince <chr>, day <int>,
#> #   gadm.level0.gid <chr>, gadm.level0.name <chr>, gadm.level1.gid <chr>,
#> #   gadm.level1.name <chr>, gadm.level2.gid <chr>, gadm.level2.name <chr>,
#> #   gadm.level3.gid <chr>, gadm.level3.name <chr>, geodeticDatum <chr>,
#> #   countryCode <chr>, country <chr>, recordNumber <chr>, municipality <chr>,
#> #   locality <chr>, datasetName <chr>, identifiedBy <chr>, continent <chr>,
#> #   typifiedName <chr>, lifeStage <chr>, infraspecificEpithet <chr>,
#> #   county <chr>, associatedReferences <chr>, verbatimElevation <chr>,
#> #   higherGeography <chr>, institutionID <chr>, island <chr>,
#> #   islandGroup <chr>, …
```

## Expand issue codes to full names

Another thing we can do with `occ_issues()` is go from issue codes to full issue names in case you want those in your dataset (here, showing only a few columns to see the data better for this demo):


```r
out <- res %>% occ_issues(mutate = "expand")
head(out$data[,c(1,5)])
#> # A tibble: 6 x 2
#>   key        publishingOrgKey                    
#>   <chr>      <chr>                               
#> 1 1039645472 2e167bb0-4441-11db-9ba2-b8a03c50a862
#> 2 1086659096 f6e2efc9-42a3-47ea-99c6-3eda8d653cc9
#> 3 1095554046 ab5c0b99-5af3-4958-b03c-0b7e85481cc1
#> 4 1135436894 58520c30-bafb-11d9-8e53-b8a03c50a862
#> 5 1135437949 58520c30-bafb-11d9-8e53-b8a03c50a862
#> 6 1135453294 58520c30-bafb-11d9-8e53-b8a03c50a862
```


## Add columns

Sometimes you may want to have each type of issue as a separate column.

Split out each issue type into a separate column, with number of columns equal to number of issue types


```r
out <- res %>% occ_issues(mutate = "split")
head(out$data[,c(1,5:10)])
#> # A tibble: 6 x 7
#>   name                             osiic gass84 txmatfuz cdround gdativ muluriiv
#>   <chr>                            <chr> <chr>  <chr>    <chr>   <chr>  <chr>   
#> 1 Psittacus erithacus Linnaeus, 1… y     n      n        n       n      n       
#> 2 Asplenium radicans L.            n     y      n        n       n      n       
#> 3 Eugenia pyriformis Cambess.      n     n      n        n       n      n       
#> 4 Marasmius epiphyllus (Pers.) Fr. n     n      n        n       n      n       
#> 5 Berkleasmium moriforme (Peck) R… n     n      n        n       n      n       
#> 6 Pseudovalsa umbonata (Tul. & C.… n     n      n        n       n      n
```

## Expand and add columns

Or you can expand each issue type into its full name, and split each issue into a separate column.


```r
out <- res %>% occ_issues(mutate = "split_expand")
head(out$data[,c(1,5:10)])
#> # A tibble: 6 x 7
#>   name  OCCURRENCE_STAT… GEODETIC_DATUM_… TAXON_MATCH_FUZ… COORDINATE_ROUN…
#>   <chr> <chr>            <chr>            <chr>            <chr>           
#> 1 Psit… y                n                n                n               
#> 2 Aspl… n                y                n                n               
#> 3 Euge… n                n                n                n               
#> 4 Mara… n                n                n                n               
#> 5 Berk… n                n                n                n               
#> 6 Pseu… n                n                n                n               
#> # … with 2 more variables: GEODETIC_DATUM_INVALID <chr>,
#> #   MULTIMEDIA_URI_INVALID <chr>
```

## Wrap up

We hope this helps users get just the data they want, and nothing more. Let us know if you have feedback on data cleaning functionality in `rgbif` at _info@ropensci.org_ or at [https://github.com/ropensci/rgbif/issues](https://github.com/ropensci/rgbif/issues).
